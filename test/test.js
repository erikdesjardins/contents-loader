import path from 'path';
import test from 'ava';

import loader from '../index';

function runLoader(request, query) {
	return new Promise((resolve, reject) => {
		loader.pitch.call({
			query,
			context: path.join(__dirname, request),
			async: () => (err, result) => err ? reject(err) : resolve(result),
			addContextDependency: () => {},
		}, request);
	});
}

test('missing trailing slash', t => {
	t.throws(runLoader('./src'), 'contents-loader: request "./src" must have a trailing slash. Try "./src/" instead.');
});

test('invalid path', t => {
	t.throws(runLoader('./notARealPath/'), /ENOENT/);
});

test('adds a context dependency', async t => {
	t.plan(2);

	await new Promise(r => {
		loader.pitch.call({
			context: path.join(__dirname, './src/'),
			async: () => (err, result) => { t.truthy(result); r(); },
			addContextDependency: path => t.is(path, './src/'),
		}, './src/');
	});
});

const header = '/* generated by contents-loader */';

test('default behaviour', async t => {
	t.is(
		await runLoader('./src/'),
		`
${header}
import * as _0 from "./src/a.js";
import * as _1 from "./src/b.js";
import * as _2 from "./src/c.js";
export default { "a.js": _0, "b.js": _1, "c.js": _2 };
		`.trim()
	);
});

test('match option - string', async t => {
	t.is(
		await runLoader('./src/', '?match=\\.txt$'),
		`
${header}
import * as _0 from "./src/test.txt";
export default { "test.txt": _0 };
		`.trim()
	);
});

test('match option - regex', async t => {
	t.is(
		await runLoader('./src/', { match: /\.(md|markdown)$/ }),
		`
${header}
import * as _0 from "./src/bar.md";
import * as _1 from "./src/baz.markdown";
import * as _2 from "./src/foo.md";
export default { "bar.md": _0, "baz.markdown": _1, "foo.md": _2 };
		`.trim()
	);
});
